service,package br.ufsc.bridge.pecassinador.localidade.common.service;\n\nimport java.util.List;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.localidade.common.dto.UfDto;\nimport br.ufsc.bridge.pecassinador.localidade.common.mapper.UfDtoMapper;\nimport br.ufsc.bridge.pecassinador.localidade.common.repository.UfRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class UfListService {\n	private final UfRepository ufRepository;\n	private final UfDtoMapper ufDtoMapper;\n\n	public List<UfDto> getUfs() {\n		return this.ufDtoMapper.toDto(this.ufRepository.findByOrderByNome());\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.localidade.common.service;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.localidade.common.enums.UfEnum;\nimport br.ufsc.bridge.pecassinador.localidade.common.repository.MunicipioRepository;\nimport br.ufsc.bridge.pecassinador.localidade.latest.dto.MunicipioDto;\nimport br.ufsc.bridge.pecassinador.localidade.latest.mapper.MunicipioMapper;\n\n@Service\n@RequiredArgsConstructor\npublic class MunicipioListService {\n	private final MunicipioRepository municipioRepository;\n	private final MunicipioMapper municipioMapper;\n\n	public List<MunicipioDto> getMunicipios(UfEnum uf, String filtro) {\n		String normalizedFiltro = Optional.ofNullable(filtro).map(StringUtils::stripAccents).orElse("""");\n\n		return this.municipioMapper.toDto(\n				this.municipioRepository.findTop10ByUfIdAndNomeFiltroStartingWithIgnoreCaseOrderByNome(\n						uf.getId(),\n						normalizedFiltro\n				));\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.auditoria.service;\n\nimport java.time.LocalDateTime;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.auditoria.enums.AuditoriaEventoEnum;\nimport br.ufsc.bridge.pecassinador.auditoria.model.AuditoriaEvento;\nimport br.ufsc.bridge.pecassinador.auditoria.model.TipoAuditoriaEvento;\nimport br.ufsc.bridge.pecassinador.auditoria.repository.AuditoriaEventoRepository;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.security.secured.SecuredContext;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.EntityNotFoundException;\nimport jakarta.persistence.PersistenceContext;\n\n@Service\n@RequiredArgsConstructor\npublic class AuditoriaEventoCreateService {\n	private final AuditoriaEventoRepository auditoriaEventoRepository;\n	private final DocumentoRepository documentoRepository;\n	private final SecuredContext securedContext;\n	@PersistenceContext\n	private EntityManager entityManager;\n\n	@Transactional\n	public void create(String codigoAcesso, AuditoriaEventoEnum evento) {\n		val prescricao = documentoRepository.findByCodigoAcesso(codigoAcesso).orElseThrow(EntityNotFoundException::new);\n		AuditoriaEvento auditoriaEvento = new AuditoriaEvento();\n		auditoriaEvento.setNomeSessao(securedContext.getName());\n		auditoriaEvento.setDocumento(prescricao);\n		auditoriaEvento.setDataCriacao(LocalDateTime.now());\n		auditoriaEvento.setTipoAuditoriaEvento(this.entityManager.getReference(TipoAuditoriaEvento.class, evento.getId()));\n		this.auditoriaEventoRepository.save(auditoriaEvento);\n	}\n\n}\n"
service,package br.ufsc.bridge.pecassinador.cidadao.latest.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.cidadao.latest.dto.CidadaoDto;\nimport br.ufsc.bridge.pecassinador.cidadao.latest.mapper.CidadaoMapper;\nimport br.ufsc.bridge.pecassinador.cidadao.latest.repository.CidadaoRepository;\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\n\n@Service\n@RequiredArgsConstructor\npublic class CidadaoCreateService implements EntityCreateService<CidadaoDto> {\n\n	private final CidadaoRepository cidadaoRepository;\n	private final CidadaoMapper cidadaoMapper;\n\n	public Long create(CidadaoDto cidadaoDto) {\n		return this.cidadaoRepository.save(this.cidadaoMapper.toEntity(cidadaoDto)).getId();\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.termo.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.termo.repository.ConfirmacaoTermoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ConfirmacaoTermoGetService {\n	private final ConfirmacaoTermoRepository confirmacaoTermoRepository;\n\n	public boolean getConfirmacaoTermo(String cpf) {\n		return this.confirmacaoTermoRepository.existsByCpfAndDataConfirmacaoTermoNotNull(cpf);\n	}\n\n}\n
service,package br.ufsc.bridge.pecassinador.termo.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.termo.model.ConfirmacaoTermo;\nimport br.ufsc.bridge.pecassinador.termo.repository.ConfirmacaoTermoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ConfirmacaoTermoAcceptService {\n	private final ConfirmacaoTermoRepository confirmacaoTermoRepository;\n\n	@Transactional\n	public void accept(String cpf) {\n		ConfirmacaoTermo confirmacaoTermo = new ConfirmacaoTermo();\n		confirmacaoTermo.setCpf(cpf);\n		this.confirmacaoTermoRepository.save(confirmacaoTermo);\n	}\n}
service,"package br.ufsc.bridge.pecassinador.atestado.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.assinatura.service.DocumentoReadFileService;\nimport br.ufsc.bridge.pecassinador.common.util.ResponseUtils;\nimport br.ufsc.bridge.pecassinador.documento.common.model.DocumentoTemporario;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\nimport br.ufsc.bridge.pecassinador.documento.common.service.DocumentoTemporarioDeleteService;\nimport br.ufsc.bridge.pecassinador.documento.latest.service.DocumentoCreateService;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class AtestadoEmitService {\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final DocumentoCreateService documentoCreateService;\n	private final DocumentoReadFileService documentoReadFileService;\n	private final DocumentoTemporarioDeleteService documentoTemporarioDeleteService;\n\n	@Transactional\n	public ResponseEntity<ByteArrayResource> emit(String codigoAcesso, Long contaServicoId) throws IOException {\n		DocumentoTemporario documentoTemporario = documentoTemporarioRepository.findByCodigoAcessoAndContaServicoIdWithDataAssinatura(codigoAcesso, contaServicoId)\n				.orElseThrow(EntityNotFoundException::new);\n\n		this.documentoCreateService.create(documentoTemporario);\n		val arquivo = documentoTemporario.getArquivo();\n		val nomeArquivo = arquivo.getNome();\n		val data = this.documentoReadFileService.read(arquivo);\n		this.documentoTemporarioDeleteService.deleteFully(documentoTemporario);\n\n		return ResponseUtils.downloadPdf(data, nomeArquivo);\n	}\n\n}\n"
service,package br.ufsc.bridge.pecassinador.common.data;\n\npublic interface EntityCreateService<TDto> {\n	Long create(TDto dto);\n}\n
service,"package br.ufsc.bridge.pecassinador.common.data;\n\npublic interface EntityUpdateService<TDto> {\n	Long update(Long id, TDto dto);\n}\n"
service,package br.ufsc.bridge.pecassinador.common.data;\n\npublic interface EntityGetOrCreateService<TDto> {\n	Long getOrCreate(TDto dto);\n}\n
service,package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.ProdutoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.ProdutoCreateDtoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.ProdutoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ProdutoCreateService implements EntityCreateService<ProdutoCreateDto> {\n\n	private final ProdutoRepository repository;\n	private final ProdutoCreateDtoMapper mapper;\n\n	@Transactional\n	public Long create(ProdutoCreateDto produto) { // TODO: #418 - Converter classe para um EntityGetOrCreateService após definição de identificador único\n		return this.repository.save(this.mapper.toEntity(produto)).getId();\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport static java.util.stream.Collectors.groupingBy;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoQueryDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.FornecimentoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Fornecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.FornecimentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class FornecimentoGetService {\n	private final FornecimentoRepository fornecimentoRepository;\n	private final FornecimentoMapper mapper;\n\n	public FornecimentoDto getFornecimento(String codigoAcesso, Long fornecimentoId) {\n		List<FornecimentoQueryDto> fornecimentos = fornecimentoRepository.getByCodigoAcessoAndId(codigoAcesso, fornecimentoId);\n		Map.Entry<Fornecimento, List<FornecimentoQueryDto>> groupedFornecimentos = fornecimentos\n				.stream()\n				.collect(groupingBy(FornecimentoQueryDto::fornecimento))\n				.entrySet()\n				.stream()\n				.findFirst()\n				.orElseThrow(EntityNotFoundException::new);\n\n		return this.mapper.toFornecimentoDto(\n				groupedFornecimentos.getKey(),\n				groupedFornecimentos.getValue().stream().map(FornecimentoQueryDto::fornecimentoReceita).toList()\n		);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport java.util.List;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.documento.common.model.Documento;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.farmaceutico.dto.FarmaceuticoCreateDto;\nimport br.ufsc.bridge.pecassinador.farmaceutico.dto.FarmaceuticoDto;\nimport br.ufsc.bridge.pecassinador.farmaceutico.model.Farmaceutico;\nimport br.ufsc.bridge.pecassinador.farmaceutico.repository.FarmaceuticoRepository;\nimport br.ufsc.bridge.pecassinador.farmaceutico.service.FarmaceuticoGetOrCreateService;\nimport br.ufsc.bridge.pecassinador.farmaceutico.service.FarmaceuticoUpdateService;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.CompradorCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoReceitaCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.EstabelecimentoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Comprador;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Estabelecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Fornecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.CompradorRepository;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.EstabelecimentoRepository;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.FornecimentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class FornecimentoCreateService {\n\n	private final FarmaceuticoGetOrCreateService farmaceuticoCreateService;\n	private final CompradorCreateService compradorCreateService;\n	private final EstabelecimentoCreateService estabelecimentoCreateService;\n	private final CompradorRepository compradorRepository;\n	private final EstabelecimentoRepository estabelecimentoRepository;\n	private final FarmaceuticoRepository farmaceuticoRepository;\n	private final FarmaceuticoUpdateService farmaceuticoUpdateService;\n	private final DocumentoRepository documentoRepository;\n	private final FornecimentoRepository fornecimentoRepository;\n	private final FornecimentoReceitaCreateService fornecimentoReceitaCreateService;\n\n	@Transactional\n	public Long create(FornecimentoCreateDto fornecimentoCreateDto, String codigoAcessoDocumento, String cpfUsuario, String nomeUsuario) {\n		val fornecimento = new Fornecimento();\n\n		Farmaceutico farmaceutico = this.resolveFarmaceutico(fornecimentoCreateDto.getFarmaceutico(), cpfUsuario, nomeUsuario);\n\n		fornecimento.setNomeResponsavel(farmaceutico.getNome());\n		fornecimento.setCrfResponsavel(farmaceutico.getCrf());\n		fornecimento.setUfConselhoClasseResponsavel(farmaceutico.getUfConselhoClasse());\n		fornecimento.setResponsavel(farmaceutico);\n		fornecimento.setDocumento(this.resolveDocumento(codigoAcessoDocumento));\n		fornecimento.setComprador(this.resolveComprador(fornecimentoCreateDto.getComprador()));\n		fornecimento.setEstabelecimento(this.resolveEstabelecimento(fornecimentoCreateDto.getEstabelecimento()));\n\n		val fornecimentoSaved = this.fornecimentoRepository.save(fornecimento);\n\n		this.saveReceitasFornecidas(fornecimentoCreateDto.getReceitas(), fornecimentoSaved);\n\n		return fornecimentoSaved.getId();\n	}\n\n	private Documento resolveDocumento(String codigoAcessoDocumento) {\n		return this.documentoRepository\n				.findByCodigoAcesso(codigoAcessoDocumento)\n				.orElseThrow(EntityNotFoundException::new);\n	}\n\n	private Farmaceutico resolveFarmaceutico(FarmaceuticoCreateDto createFarmaceuticoDto, String cpfUsuario, String nomeUsuario) {\n		FarmaceuticoDto farmaceuticoDto = new FarmaceuticoDto();\n		farmaceuticoDto.setCpf(cpfUsuario);\n		farmaceuticoDto.setNome(nomeUsuario);\n		if (createFarmaceuticoDto != null) {\n			farmaceuticoDto.setCrf(createFarmaceuticoDto.getCrf());\n			farmaceuticoDto.setUfConselhoClasse(createFarmaceuticoDto.getUfConselhoClasse());\n		}\n		val farmaceuticoId = farmaceuticoCreateService.getOrCreate(farmaceuticoDto);\n		return farmaceuticoRepository.getReferenceById(farmaceuticoUpdateService.update(farmaceuticoId, farmaceuticoDto));\n	}\n\n	private Comprador resolveComprador(CompradorCreateDto compradorDto) {\n		if (compradorDto != null) {\n			val compradorId = this.compradorCreateService.create(compradorDto);\n			return this.compradorRepository.getReferenceById(compradorId);\n		} else {\n			return null;\n		}\n	}\n\n	private Estabelecimento resolveEstabelecimento(EstabelecimentoCreateDto estabelecimentoDto) {\n		if (estabelecimentoDto != null) {\n			val estabelecimentoId = this.estabelecimentoCreateService.create(estabelecimentoDto);\n			return this.estabelecimentoRepository.getReferenceById(estabelecimentoId);\n		} else {\n			return null;\n		}\n	}\n\n	private void saveReceitasFornecidas(List<FornecimentoReceitaCreateDto> medicamentos, Fornecimento fornecimentoSaved) {\n		medicamentos.forEach(receita -> {\n			this.fornecimentoReceitaCreateService.create(fornecimentoSaved, receita);\n		});\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoReceitaCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.ProdutoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.FornecimentoReceitaCreateDtoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Fornecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Produto;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.FornecimentoReceitaRepository;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.ProdutoRepository;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.common.model.ReceitaMedicamento;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.repository.ReceitaMedicamentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class FornecimentoReceitaCreateService {\n\n	private final FornecimentoReceitaRepository repository;\n	private final FornecimentoReceitaCreateDtoMapper mapper;\n	private final ReceitaMedicamentoRepository receitaMedicamentoRepository;\n	private final ProdutoCreateService produtoCreateService;\n	private final ProdutoRepository produtoRepository;\n\n	@Transactional\n	public Long create(Fornecimento fornecimento, FornecimentoReceitaCreateDto fornecimentoReceitaCreateDto) {\n		val fornecimentoReceita = mapper.toEntity(fornecimentoReceitaCreateDto);\n\n		fornecimentoReceita.setFornecimento(fornecimento);\n		fornecimentoReceita.setProduto(resolveProduto(fornecimentoReceitaCreateDto.getProduto()));\n		fornecimentoReceita.setReceitaMedicamento(resolveReceitaMedicamento(fornecimentoReceitaCreateDto.getReceitaMedicamentoId()));\n\n		return repository.save(fornecimentoReceita).getId();\n	}\n\n	private Produto resolveProduto(ProdutoCreateDto produtoDto) {\n		return Optional.ofNullable(produtoDto)\n				.map(produto -> produtoRepository.getReferenceById(produtoCreateService.create(produtoDto)))\n				.orElse(null);\n	}\n\n	private ReceitaMedicamento resolveReceitaMedicamento(Long receitaId) {\n		return receitaMedicamentoRepository\n				.findByReceitaId(receitaId)\n				.orElseThrow(EntityNotFoundException::new);\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.EstabelecimentoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.EstabelecimentoCreateDtoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Estabelecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.EnderecoRepository;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.EstabelecimentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class EstabelecimentoCreateService implements EntityCreateService<EstabelecimentoCreateDto> {\n\n	private final EstabelecimentoRepository repository;\n	private final EstabelecimentoCreateDtoMapper mapper;\n	private final EnderecoCreateService enderecoCreateService;\n	private final EnderecoRepository enderecoRepository;\n\n	@Transactional\n	public Long create(EstabelecimentoCreateDto estabelecimentoDto) {\n		Estabelecimento estabelecimentoModel = this.mapper.toEntity(estabelecimentoDto);\n		if (estabelecimentoDto.getEndereco() != null) {\n			Long enderecoId = this.enderecoCreateService.create(estabelecimentoDto.getEndereco());\n			estabelecimentoModel.setEndereco(this.enderecoRepository.getReferenceById(enderecoId));\n		}\n\n		return this.repository.save(estabelecimentoModel).getId();\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport static java.util.stream.Collectors.groupingBy;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.FornecimentoQueryDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.FornecimentoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.Fornecimento;\nimport br.ufsc.bridge.pecassinador.fornecimento.model.FornecimentoReceita;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.FornecimentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class FornecimentoListService {\n	private final FornecimentoRepository fornecimentoRepository;\n	private final FornecimentoMapper mapper;\n\n	public List<FornecimentoDto> getFornecimentos(String codigoAcesso) {\n		List<FornecimentoQueryDto> fornecimentos = fornecimentoRepository.findAllByCodigoAcessoDocumento(codigoAcesso);\n		return fornecimentos.stream()\n				.collect(groupingBy(\n						FornecimentoQueryDto::fornecimento,\n						LinkedHashMap::new,\n						Collectors.toList()\n				))\n				.entrySet()\n				.stream()\n				.map(entry -> {\n					Fornecimento fornecimento = entry.getKey();\n					List<FornecimentoQueryDto> fornecimentosValue = entry.getValue();\n					List<FornecimentoReceita> receitasFornecidas = fornecimentosValue.stream().map(FornecimentoQueryDto::fornecimentoReceita).collect(toList());\n					return mapper.toFornecimentoDto(fornecimento, receitasFornecidas);\n				})\n				.collect(toList());\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.EnderecoCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.EnderecoCreateDtoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.EnderecoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class EnderecoCreateService implements EntityCreateService<EnderecoCreateDto> {\n\n	private final EnderecoRepository repository;\n	private final EnderecoCreateDtoMapper mapper;\n\n	@Transactional\n	public Long create(EnderecoCreateDto enderecoDto) {\n		return this.repository.save(this.mapper.toEntity(enderecoDto)).getId();\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.fornecimento.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.fornecimento.dto.CompradorCreateDto;\nimport br.ufsc.bridge.pecassinador.fornecimento.mapper.CompradorCreateDtoMapper;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.CompradorRepository;\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.EnderecoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class CompradorCreateService implements EntityCreateService<CompradorCreateDto> {\n\n	private final CompradorRepository repository;\n	private final CompradorCreateDtoMapper mapper;\n	private final EnderecoCreateService enderecoCreateService;\n	private final EnderecoRepository enderecoRepository;\n\n	@Transactional\n	public Long create(CompradorCreateDto compradorDto) {\n		val compradorModel = this.mapper.toEntity(compradorDto);\n		if (!compradorDto.getEstrangeiro() && compradorDto.getEndereco() != null) {\n			val enderecoId = this.enderecoCreateService.create(compradorDto.getEndereco());\n			compradorModel.setEndereco(this.enderecoRepository.getReferenceById(enderecoId));\n		}\n\n		return this.repository.save(compradorModel).getId();\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static com.google.zxing.BarcodeFormat.QR_CODE;\nimport static com.google.zxing.client.j2se.MatrixToImageWriter.toBufferedImage;\n\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport javax.imageio.ImageIO;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport com.google.zxing.EncodeHintType;\nimport com.google.zxing.qrcode.QRCodeWriter;\nimport com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;\n\n@Service\n@RequiredArgsConstructor\npublic class GenerateQrCodeService {\n\n	@SneakyThrows\n	public byte[] generateQrCode(String url) {\n		val hintMap = new Hashtable<EncodeHintType, Object>();\n		hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);\n		hintMap.put(EncodeHintType.MARGIN, 0);\n\n		val qrCodeWriter = new QRCodeWriter();\n		val bitMatrix = qrCodeWriter.encode(url, QR_CODE, 0, 0, hintMap);\n		val bufferedImage = toBufferedImage(bitMatrix);\n\n		return toByteArray(bufferedImage);\n	}\n\n	private byte[] toByteArray(BufferedImage bi) throws IOException {\n		val baos = new ByteArrayOutputStream();\n\n		ImageIO.write(bi, ""png"", baos);\n\n		return baos.toByteArray();\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\nimport java.io.ByteArrayInputStream;\nimport java.security.Security;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.List;\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.apache.pdfbox.io.IOUtils;\nimport org.bouncycastle.cert.jcajce.JcaCertStore;\nimport org.bouncycastle.cms.CMSProcessableByteArray;\nimport org.bouncycastle.cms.CMSSignedDataGenerator;\nimport org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator;\nimport org.bouncycastle.cms.SignerInformationVerifier;\nimport org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.operator.ContentVerifierProvider;\nimport org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder;\nimport org.bouncycastle.operator.DigestCalculatorProvider;\nimport org.bouncycastle.operator.OperatorCreationException;\nimport org.bouncycastle.operator.bc.BcDigestCalculatorProvider;\nimport org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder;\nimport org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.assinatura.dto.ExternalSignerDto;\nimport br.ufsc.bridge.pecassinador.security.secured.SecuredContext;\n\nimport jakarta.annotation.PostConstruct;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class IntegraIcpSignService implements ExternalSigner {\n	private final SecuredContext securedContext;\n\n	@PostConstruct\n	private void init() {\n		Security.addProvider(new BouncyCastleProvider());\n	}\n\n	@Override\n	@SneakyThrows\n	public Optional<byte[]> sign(ExternalSignerDto externalSignerDto) {\n		val dataBytes = IOUtils.toByteArray(externalSignerDto.content());\n		val credentials = externalSignerDto.credentials();\n		val contentSigner = new IcpContentSigner(externalSignerDto);\n		val certificateFactory = CertificateFactory.getInstance(""X.509"");\n		val certificate = (X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(credentials.encodedX509().getBytes(US_ASCII)));\n		val store = new JcaCertStore(List.of(certificate));\n		val digestCalculatorProvider = new BcDigestCalculatorProvider();\n\n		val content = new CMSProcessableByteArray(\n				dataBytes); //TODO: verificar possibilidade de fazer a requisicao da assinatura antes e utilizar ContentSigner / DigestCalculatorProvider pre-calculados\n		val signedDataGenerator = new CMSSignedDataGenerator();\n\n		signedDataGenerator.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(digestCalculatorProvider).build(contentSigner, certificate));\n		signedDataGenerator.addCertificates(store);\n\n		val signedData = signedDataGenerator.generate(content, false);\n		val signerInformation = signedData.getSignerInfos().getSigners().iterator().next();\n\n		val verify = signerInformation.verify(this.getSignerInformationVerifier(certificate));\n\n		if (!verify) {\n			log.error(""Falha ao gerar assinatura para o documento."");\n			return Optional.empty();\n		}\n\n		return Optional.of(signedData.getEncoded());\n	}\n\n	private SignerInformationVerifier getSignerInformationVerifier(X509Certificate signerCertificate) throws OperatorCreationException {\n\n		val contentVerifierProviderBuilder = new JcaContentVerifierProviderBuilder();\n		ContentVerifierProvider contentVerifierProvider;\n		DigestCalculatorProvider digestCalculatorProvider;\n\n		if (signerCertificate == null) {\n			return null;\n		}\n\n		contentVerifierProvider = contentVerifierProviderBuilder.build(signerCertificate);\n		digestCalculatorProvider = new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build();\n\n		val cmsSignatureAlgorithmNameGenerator = new DefaultCMSSignatureAlgorithmNameGenerator();\n		val signatureAlgorithmIdentifierFinder = new DefaultSignatureAlgorithmIdentifierFinder();\n\n		return new SignerInformationVerifier(cmsSignatureAlgorithmNameGenerator, signatureAlgorithmIdentifierFinder, contentVerifierProvider, digestCalculatorProvider);\n	}\n\n}\n\n\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport java.awt.Color;\nimport java.awt.geom.Rectangle2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.pdmodel.PDPage;\nimport org.apache.pdfbox.pdmodel.PDPageContentStream;\nimport org.apache.pdfbox.pdmodel.font.PDType0Font;\nimport org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceStream;\nimport org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature;\nimport org.apache.pdfbox.pdmodel.interactive.form.PDSignatureField;\nimport org.apache.pdfbox.util.Matrix;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.assinatura.dto.EmissorSignatureDto;\nimport br.ufsc.bridge.pecassinador.common.util.PdfLabelUtils;\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\n\n@Service\n@Slf4j\n@RequiredArgsConstructor\npublic class SignatureLabelService {\n	private static final int QTD_NEW_LINES = 8;\n	private final AssinaturaUrlBuildService assinaturaUrlBuildService;\n	private final SignatureLabelQrCodeService signatureLabelQrCodeService;\n\n	public ByteArrayInputStream createSignatureLabel(\n			PDDocument doc,\n			String codigoAcesso,\n			PDSignature signature,\n			Integer pageNum,\n			EmissorSignatureDto emissorSignatureDto,\n			TipoDocumentoEnum tipoDocumento) throws IOException {\n		try (val targetDoc = new PDDocument()) {\n			val page = doc.getPage(pageNum);\n			val pageOrientation = page.getRotation();\n\n			val referenceRect = new Rectangle2D.Float(\n					19f,\n					100f,\n					PdfLabelUtils.getPageWidth(page),\n					PdfLabelUtils.getPageHeight(page)\n			);\n			val visualRect = PdfLabelUtils.createVisualRectangle(\n					page,\n					referenceRect,\n					pageOrientation\n			);\n\n			val targetPage = new PDPage(page.getCOSObject());\n			targetDoc.addPage(targetPage);\n\n			val acroForm = PdfLabelUtils.setAcroForm(targetDoc);\n			val formXObject = PdfLabelUtils.setFormXObject(targetDoc, visualRect);\n			val textHeight = (pageOrientation % 180 != 0)\n					? formXObject.getBBox().getWidth()\n					: formXObject.getBBox().getHeight();\n			val scaleMatrix = PdfLabelUtils.setScaleMatrix(formXObject, pageOrientation);\n			val signatureField = new PDSignatureField(acroForm);\n			val widget = signatureField.getWidgets().get(0);\n\n			acroForm.getFields().add(signatureField);\n			widget.setRectangle(visualRect);\n			val appearance = PdfLabelUtils.setWidgetAppearance(formXObject, widget);\n\n			this.applyVisualLabel(\n					targetDoc,\n					codigoAcesso,\n					signature,\n					appearance.getNormalAppearance().getAppearanceStream(),\n					scaleMatrix.orElse(null),\n					textHeight,\n					emissorSignatureDto,\n					tipoDocumento\n			);\n\n			val outputStream = new ByteArrayOutputStream();\n			targetDoc.save(outputStream);\n\n			return new ByteArrayInputStream(outputStream.toByteArray());\n		}\n	}\n\n	private void applyVisualLabel(\n			PDDocument doc,\n			String codigoAcesso,\n			PDSignature signature,\n			PDAppearanceStream appearanceStream,\n			Matrix scaleMatrix,\n			Float textHeight,\n			EmissorSignatureDto emissorSignatureDto,\n			TipoDocumentoEnum tipoDocumento) throws IOException {\n		try (val contentStream = new PDPageContentStream(doc, appearanceStream)) {\n			ClassPathResource res = new ClassPathResource(""fonts/Lato-Regular.ttf"");\n			ClassPathResource boldRes = new ClassPathResource(""fonts/Lato-Bold.ttf"");\n			PDType0Font font = PDType0Font.load(doc, res.getInputStream());\n			PDType0Font boldFont = PDType0Font.load(doc, boldRes.getInputStream());\n\n			val fontSize = 6f;\n			val lineHeight = fontSize * 1.1f;\n			val textoAuxOffset = lineHeight * QTD_NEW_LINES;\n			val date = signature.getSignDate().getTime();\n			val timestamp = new SimpleDateFormat(""dd/MM/yyyy HH:mm:ss"").format(date);\n			val txQrCode = fontSize + 65f;\n			val tyQrCode = textHeight - lineHeight - 20f;\n\n			if (scaleMatrix != null) {\n				contentStream.transform(scaleMatrix);\n			}\n\n			switch (tipoDocumento) {\n				case ATESTADO -> {\n				}\n				case PRESCRICAO_COMUM, PRESCRICAO_CONTROLADA -> {\n					signatureLabelQrCodeService.applyQRCode(\n							doc,\n							contentStream,\n							assinaturaUrlBuildService.buildUrlAcessoPrescricao(codigoAcesso)\n					);\n				}\n			}\n\n			contentStream.beginText();\n			contentStream.setFont(font, fontSize);\n			contentStream.setNonStrokingColor(Color.black);\n			contentStream.setLeading(lineHeight);\n\n			switch (tipoDocumento) {\n				case ATESTADO -> {\n					contentStream.newLineAtOffset(txQrCode, tyQrCode - textoAuxOffset);\n				}\n				case PRESCRICAO_COMUM, PRESCRICAO_CONTROLADA -> {\n					contentStream.newLineAtOffset(txQrCode, tyQrCode);\n					signatureLabelQrCodeService.applyQrCodeAuxText(\n							contentStream,\n							codigoAcesso,\n							font,\n							boldFont,\n							fontSize\n					);\n				}\n			}\n\n			applyFooter(contentStream, emissorSignatureDto, -txQrCode + fontSize, timestamp);\n\n			contentStream.endText();\n		}\n	}\n\n	private void applyFooter(\n			PDPageContentStream contentStream,\n			EmissorSignatureDto emissorSignatureDto,\n			float offsetX,\n			String timestamp\n	) throws IOException {\n		contentStream.newLineAtOffset(offsetX, -643f);\n		contentStream.showText(String.format(\n				""Documento emitido e assinado digitalmente por %1$s (%2$s - %3$s %4$s)"",\n				emissorSignatureDto.nome(),\n				emissorSignatureDto.siglaConselhoClasse(),\n				emissorSignatureDto.ufConselhoClasse(),\n				emissorSignatureDto.nuConselhoClasse()\n		));\n		contentStream.newLine();\n		contentStream.showText(String.format(\n				""através do sistema e-SUS APS PEC em %1$s. Verifique a autenticidade em https://validar.iti.gov.br"",\n				timestamp\n		));\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static br.ufsc.bridge.pecassinador.auditoria.enums.AuditoriaEventoEnum.VALIDAR_ASSINATURA;\nimport static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;\n\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.bouncycastle.asn1.x500.X500Name;\nimport org.bouncycastle.asn1.x500.style.BCStyle;\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.web.client.HttpServerErrorException;\nimport org.springframework.web.client.RestTemplate;\n\nimport br.ufsc.bridge.pecassinador.assinatura.dto.SignatureValidateResponseDto;\nimport br.ufsc.bridge.pecassinador.assinatura.dto.ValidaItiResponseDto;\nimport br.ufsc.bridge.pecassinador.auditoria.service.AuditoriaEventoCreateService;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class SignatureValidateService {\n\n	static {\n		System.setProperty(""sun.net.http.allowRestrictedHeaders"", ""true"");\n	}\n\n	private static final String DEFAULT_EXCEPTION_MESSAGE = ""Não foi possível verificar a validade da assinatura."";\n	private static final String NULL_RESPONSE_BODY_ERROR_MESSAGE = ""Corpo da resposta nulo. Comportamento inesperado."";\n	private static final String BASE_API = ""https://validar.iti.gov.br"";\n	private static final String STATUS_APROVADO = ""Aprovado"";\n	private final DocumentoReadFileService documentoReadFileService;\n	private final AuditoriaEventoCreateService auditoriaEventoCreateService;\n\n	public SignatureValidateResponseDto validate(String codigoAcesso) {\n		this.auditoriaEventoCreateService.create(codigoAcesso, VALIDAR_ASSINATURA);\n		val restTemplate = new RestTemplate();\n\n		try {\n			val documentBytes = this.documentoReadFileService.read(codigoAcesso);\n			val request = this.buildRequestEntity(documentBytes);\n			val response = restTemplate.postForEntity(BASE_API + ""/arquivo"", request, ValidaItiResponseDto[].class);\n			if (response.getBody() == null) {\n				throw new Exception(NULL_RESPONSE_BODY_ERROR_MESSAGE);\n			}\n			return this.buildSignatureValidateResponseDto(response.getBody());\n		} catch (Exception e) {\n			log.error(DEFAULT_EXCEPTION_MESSAGE, e);\n			throw new HttpServerErrorException(INTERNAL_SERVER_ERROR, DEFAULT_EXCEPTION_MESSAGE);\n		}\n	}\n\n	private HttpEntity<LinkedMultiValueMap<Object, Object>> buildRequestEntity(byte[] pdf) {\n		val headers = new HttpHeaders();\n		val bodyBuilder = new LinkedMultiValueMap<>();\n\n		headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n		headers.set(HttpHeaders.ORIGIN, BASE_API);\n		bodyBuilder.add(""signature_files[]"", new ByteArrayResource(pdf) {\n			@Override\n			public String getFilename() {\n				return ""-"";\n			}\n		});\n\n		return new HttpEntity<>(bodyBuilder, headers);\n	}\n\n	private SignatureValidateResponseDto buildSignatureValidateResponseDto(ValidaItiResponseDto[] response) {\n		LocalDateTime dataAssinatura = null;\n		String cpfAssinador = null;\n		String nomeAssinador = null;\n\n		val responseBody = response[0];\n\n		val report = responseBody.verifierReport().report();\n\n		val isValido = report\n				.generalStatus()\n				.equals(STATUS_APROVADO);\n		val formatter = DateTimeFormatter.ofPattern(""dd/MM/yyyy HH:mm:ss zzz"");\n\n		if (isValido) {\n			val signature = report\n					.signatures()\n					.signature();\n			val signer = signature\n					.certification()\n					.signer();\n			cpfAssinador = signer\n					.extensions()\n					.subjectAlternativeNames()\n					.generalName()\n					.value();\n			nomeAssinador = new X500Name(\n					signer.subjectName()\n			).getRDNs(BCStyle.CN)[0]\n					.getFirst()\n					.getValue()\n					.toString()\n					.split("":"", 2)[0];\n			dataAssinatura = LocalDateTime.parse(\n					report.signatures().signature().signingTime(),\n					formatter\n			);\n		}\n\n		return new SignatureValidateResponseDto(isValido, cpfAssinador, nomeAssinador, dataAssinatura);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.CONTA_NIVEL_INSUFICIENTE;\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.FALHA_OBTER_ASSINATURA;\nimport static org.springframework.http.HttpMethod.POST;\n\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.HttpClientErrorException;\nimport org.springframework.web.client.RestTemplate;\n\nimport br.ufsc.bridge.pecassinador.assinatura.dto.ExternalSignerDto;\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\n\nimport jakarta.annotation.PostConstruct;\n\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class ItiSignService implements ExternalSigner {\n	private static final String DEFAULT_BASE_API = ""https://assinatura-api.iti.br/externo/v2/assinarPKCS7"";\n\n	private final RuntimeConstants runtimeConstants;\n	private String baseApi;\n\n	@PostConstruct\n	private void init() {\n		val isItiStaging = this.runtimeConstants.getItiBaseUri().toLowerCase().contains(""staging"");\n		this.baseApi = isItiStaging ? DEFAULT_BASE_API.replace("".iti.br"", "".staging.iti.br"") : DEFAULT_BASE_API;\n	}\n\n	@Override\n	public Optional<byte[]> sign(ExternalSignerDto externalSignerDto) throws SignatureException {\n		byte[] signature = null;\n\n		try {\n			val digest = DigestUtils.sha256(externalSignerDto.content());\n			val hashBase64 = new String(Base64.getEncoder().encode(digest));\n			val request = this.buildRequestEntity(hashBase64, externalSignerDto.credentials().code());\n			val restTemplate = new RestTemplate();\n\n			signature = restTemplate.exchange(\n					this.baseApi,\n					POST,\n					request,\n					byte[].class\n			).getBody();\n		} catch (Exception e) {\n			this.handleException(e);\n		}\n\n		return Optional.ofNullable(signature);\n	}\n\n	private void handleException(Exception e) throws SignatureException {\n		val isNivelInsuficiente = e instanceof HttpClientErrorException errorException\n				&& HttpStatus.FORBIDDEN.equals(errorException.getStatusCode())\n				&& errorException.getResponseBodyAsString().toLowerCase().contains(""não possui a identidade (prata ou ouro)"");\n\n		throw new SignatureException(isNivelInsuficiente ? CONTA_NIVEL_INSUFICIENTE : FALHA_OBTER_ASSINATURA);\n	}\n\n	private HttpEntity buildRequestEntity(String hashBase64, String accessToken) {\n		val headers = new HttpHeaders();\n		headers.setAccept(List.of(MediaType.ALL));\n		headers.setContentType(MediaType.APPLICATION_JSON);\n		headers.setBearerAuth(accessToken);\n		val body = new HashMap<String, String>();\n		body.put(""hashBase64"", hashBase64);\n\n		return new HttpEntity(body, headers);\n	}\n\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.MDPAccessPermissionEnum.APENAS_ASSINATURAS;\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.MDPAccessPermissionEnum.FINAL;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.Calendar;\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature;\nimport org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.assinatura.dto.ExternalSignerDto;\nimport br.ufsc.bridge.pecassinador.assinatura.dto.PdfSignerDto;\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\nimport br.ufsc.bridge.pecassinador.common.util.PDSignUtil;\n\n@RequiredArgsConstructor\n@Slf4j\n@Service\npublic class PdfSignService {\n	private final SignatureLabelService labelService;\n	private final IntegraIcpSignService integraIcpSignService;\n	private final ItiSignService itiSignService;\n	private final PdfSignatureVerifyCpfService pdfSignatureVerifyCpfService;\n\n	public Optional<byte[]> sign(PdfSignerDto pdfSignerDto) throws Exception {\n		val docInputStream = new ByteArrayInputStream(pdfSignerDto.data());\n		val signedDocOutputStream = new ByteArrayOutputStream();\n		val pdDocument = PDDocument.load(docInputStream);\n		val accessPermissions = PDSignUtil.getMDPPermission(pdDocument);\n\n		if (accessPermissions == FINAL) {\n			throw new IllegalStateException(\n					""Alterações ao documento não são permitidas em consequência dos parâmetros de transformação do dicionário DocMDP""\n			);\n		}\n\n		val signature = new PDSignature();\n		signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);\n		signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);\n		signature.setSignDate(Calendar.getInstance());\n\n		if (accessPermissions == null) {\n			PDSignUtil.setMDPPermission(pdDocument, signature, APENAS_ASSINATURAS);\n		}\n\n		try (val signatureOptions = new SignatureOptions()) {\n			signatureOptions.setPage(0);\n			signatureOptions.setVisualSignature(this.labelService.createSignatureLabel(pdDocument, pdfSignerDto.codigoAcesso(), signature, 0, pdfSignerDto.emissor(),\n					pdfSignerDto.tipoDocumento()));\n			pdDocument.addSignature(signature, null, signatureOptions);\n			val externalSigningSupport = pdDocument.saveIncrementalForExternalSigning(signedDocOutputStream);\n			val externalSignature = this.signContent(externalSigningSupport.getContent(), pdfSignerDto);\n			externalSigningSupport.setSignature(externalSignature);\n		}\n\n		pdDocument.close();\n\n		return Optional.of(signedDocOutputStream.toByteArray());\n	}\n\n	private byte[] signContent(InputStream content, PdfSignerDto pdfSignerDto) throws SignatureException {\n		val externalSignerDto = new ExternalSignerDto(content, pdfSignerDto.emissor().cpf(), pdfSignerDto.credentials());\n		val hasVerifier = StringUtils.isNotBlank(pdfSignerDto.credentials().verifier());\n		val externalSigner = hasVerifier ? this.integraIcpSignService : this.itiSignService;\n		val signature = externalSigner.sign(externalSignerDto).orElse(null);\n\n		this.pdfSignatureVerifyCpfService.verify(signature, externalSignerDto.signerCpf());\n\n		return signature;\n	}\n}"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class DocumentoGenerateAccessCodeService {\n	private final DocumentoRepository documentoRepository;\n	private final CodeService codeService;\n\n	public String generateUniqueAccessCode() {\n		var code = """";\n		var isUnique = false;\n\n		while (!isUnique) {\n			code = this.codeService.generate();\n			isUnique = !this.documentoRepository.existsByCodigoAcesso(code);\n		}\n\n		return code;\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.DOCUMENTO_JA_ASSINADO;\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.FALHA_OBTER_ASSINATURA;\nimport static java.lang.String.format;\nimport static java.time.LocalDateTime.now;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.arquivo.service.ArquivoCreateService;\nimport br.ufsc.bridge.pecassinador.arquivo.service.ArquivoDeleteService;\nimport br.ufsc.bridge.pecassinador.assinatura.dto.EmissorSignatureDto;\nimport br.ufsc.bridge.pecassinador.assinatura.dto.PdfSignerDto;\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\nimport br.ufsc.bridge.pecassinador.contaservico.repository.ContaServicoRepository;\nimport br.ufsc.bridge.pecassinador.documento.common.dto.DocumentoSignDto;\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\nimport br.ufsc.bridge.pecassinador.documento.latest.mapper.DocumentoTemporarioMapper;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class DocumentoSignService {\n	private final PdfSignService pdfSignService;\n	private final DocumentoGenerateAccessCodeService documentoGenerateAccessCodeService;\n	private final ContaServicoRepository contaServicoRepository;\n	private final DocumentoReadFileService documentoReadFileService;\n	private final ArquivoCreateService arquivoCreateService;\n	private final ArquivoDeleteService arquivoDeleteService;\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final DocumentoTemporarioMapper documentoTemporarioMapper;\n\n	@Transactional\n	public String sign(DocumentoSignDto documentoSignRequestDto) {\n\n		EmissorSignatureDto emissorSignatureDto;\n\n		String redirectUri;\n		UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromUriString("""");\n\n		try {\n\n			val documento = this.documentoTemporarioRepository\n					.findById(documentoSignRequestDto.getId())\n					.orElseThrow(EntityNotFoundException::new);\n\n			val tipoDocumento = TipoDocumentoEnum.getById(documento.getTipoDocumento().getId());\n\n			redirectUri = this.contaServicoRepository\n					.getRedirectUriById(documento.getContaServico().getId())\n					.orElseThrow(EntityNotFoundException::new);\n\n			uriBuilder = UriComponentsBuilder.fromUriString(redirectUri);\n\n			val emissorDto = this.documentoTemporarioMapper.toEmissorDto(documento);\n\n			emissorSignatureDto = new EmissorSignatureDto(\n					emissorDto.getCpf(),\n					emissorDto.getNome(),\n					emissorDto.getNumeroConselhoClasse(),\n					emissorDto.getUfEmissoraConselhoClasse(),\n					emissorDto.getSiglaConselhoClasse()\n			);\n\n			if (documento.getDataAssinatura() != null) {\n				throw new SignatureException(DOCUMENTO_JA_ASSINADO);\n			}\n\n			val codigoAcesso = this.documentoGenerateAccessCodeService.generateUniqueAccessCode();\n\n			val oldArquivo = documento.getArquivo();\n			val pdfFile = this.documentoReadFileService.read(oldArquivo);\n			val pdfSignerDto = new PdfSignerDto(pdfFile, codigoAcesso, emissorSignatureDto, documentoSignRequestDto.getCredentials(), tipoDocumento);\n			val signedPdf = this.pdfSignService.sign(pdfSignerDto)\n					.orElseThrow(\n							() -> new Exception(""Impossível inserir objeto de assinatura nula no documento."")\n					);\n\n			documento.setCodigoAcesso(codigoAcesso);\n			val newArquivo = this.arquivoCreateService.create(oldArquivo.getNome(), signedPdf);\n			this.arquivoDeleteService.delete(oldArquivo);\n\n			documento.setArquivo(newArquivo);\n			documento.setDataAssinatura(now());\n\n			this.documentoTemporarioRepository.save(documento);\n			// TODO (#194): queryParam ser documentoId\n			uriBuilder.queryParam(""prescricaoId"", documento.getCodigoAcesso());\n		} catch (EntityNotFoundException e) {\n			log.error(format(""Erro ao obter dados para gerar o documento com id %d."", documentoSignRequestDto.getId()), e);\n		} catch (Exception e) {\n			log.error(format(""Não foi possível assinar o documento: %s"", e.getMessage()), e);\n			uriBuilder.queryParam(""error"", this.getErrorCode(e));\n		}\n\n		return uriBuilder.build().toUriString();\n	}\n\n	private int getErrorCode(Exception exception) {\n		return exception instanceof SignatureException signatureException ? signatureException.getCode() : FALHA_OBTER_ASSINATURA.getId();\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport java.security.SecureRandom;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class CodeService {\n	private static final List<Character> DIGITS_LIST = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"".chars().mapToObj(c -> (char) c).toList();\n\n	private static final Map<Character, Integer> DIGITS_MAP = DIGITS_LIST.stream().collect(Collectors.toMap(Function.identity(), DIGITS_LIST::indexOf));\n\n	public String generate() {\n		val secureRandom = new SecureRandom();\n		val sb = new StringBuilder();\n		var sum = 0;\n\n		for (int i = 0; i < 7; i++) {\n			val nextIndex = secureRandom.nextInt(DIGITS_LIST.size());\n			sb.append(DIGITS_LIST.get(nextIndex));\n			sum += nextIndex * (7 - i);\n		}\n\n		sb.append(DIGITS_LIST.get(sum % DIGITS_LIST.size()));\n\n		return sb.toString();\n	}\n\n	public boolean isValid(String code) {\n		var sum = 0;\n\n		if (code.length() != 8) {\n			return false;\n		}\n\n		for (int i = 0; i < code.length() - 1; i++) {\n			val index = DIGITS_MAP.getOrDefault(code.charAt(i), -1);\n\n			if (index < 0) {\n				return false;\n			}\n\n			sum += index * (7 - i);\n		}\n\n		val expectedLastDigit = DIGITS_LIST.get(sum % DIGITS_MAP.size());\n		val actualDigit = code.charAt(code.length() - 1);\n\n		return expectedLastDigit.equals(actualDigit);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.arquivo.model.Arquivo;\nimport br.ufsc.bridge.pecassinador.arquivo.service.StorageReadService;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class DocumentoReadFileService {\n	private final StorageReadService storageReadService;\n	private final DocumentoRepository documentoRepository;\n\n	public byte[] read(String codigoAcesso) throws IOException {\n		val arquivo = this.documentoRepository\n				.findArquivoByCodigoAcesso(codigoAcesso)\n				.orElseThrow(EntityNotFoundException::new);\n\n		return this.read(arquivo);\n	}\n\n	public byte[] read(Arquivo arquivo) throws IOException {\n		return this.storageReadService.read(arquivo.getHash() + ""_"" + arquivo.getTamanho());\n	}\n\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\n\n@Service\n@RequiredArgsConstructor\npublic class AssinaturaUrlBuildService {\n\n	private final RuntimeConstants runtimeConstants;\n\n	public String buildUrlAcessoPrescricao(String codigoAcesso) {\n		return UriComponentsBuilder\n				.fromUriString(""{publicUri}/farmacia/prescricoes/{codigoAcesso}"")\n				.buildAndExpand(runtimeConstants.getPublicUri(), codigoAcesso)\n				.toUriString();\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.CPFS_DIFERENTES;\nimport static br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum.FALHA_OBTER_ASSINATURA;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1TaggedObject;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERPrintableString;\nimport org.bouncycastle.asn1.x509.Extension;\nimport org.bouncycastle.asn1.x509.GeneralNames;\nimport org.bouncycastle.cms.CMSException;\nimport org.bouncycastle.cms.CMSSignedData;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\n\n@Slf4j\n@Service\npublic class PdfSignatureVerifyCpfService {\n	private static final String OID_CPF_PF = ""2.16.76.1.3.1"";\n	private static final String OID_CPF_PJ = ""2.16.76.1.3.4"";\n\n	public void verify(byte[] signature, String expectedCpf) throws SignatureException {\n		CMSSignedData signedData = null;\n\n		try {\n			signedData = new CMSSignedData(signature);\n		} catch (CMSException e) {\n			log.error(""Invalid signature data"", e);\n			throw new SignatureException(FALHA_OBTER_ASSINATURA, e);\n		}\n\n		val certificate = signedData.getCertificates().getMatches(null).iterator().next();\n		val generalNames = GeneralNames.fromExtensions(certificate.getExtensions(), Extension.subjectAlternativeName).getNames();\n\n		for (val generalName : generalNames) {\n			val name = generalName.getName();\n\n			if (name instanceof ASN1Sequence) {\n\n				val sequence = ASN1Sequence.getInstance(name);\n				val oid = ((ASN1ObjectIdentifier) sequence.getObjectAt(0)).getId();\n\n				if (Set.of(OID_CPF_PF, OID_CPF_PJ).contains(oid)) {\n					val content = this.getString(sequence);\n					val cpf = Objects.requireNonNull(content).substring(8, 19); // 8 primeiros são a data de nascimento\n\n					if (cpf.equals(expectedCpf)) {\n						return;\n					}\n				}\n			}\n		}\n\n		throw new SignatureException(CPFS_DIFERENTES);\n	}\n\n	private String getString(ASN1Sequence asn1) {\n		ASN1Primitive tagged = (ASN1Primitive) asn1.getObjectAt(1);\n		while (tagged instanceof ASN1TaggedObject) {\n			//TODO: fix getObject(deprecated)\n			tagged = (ASN1TaggedObject.getInstance(tagged)).getObject();\n		}\n		byte[] octetStringBytes;\n		if (tagged instanceof DEROctetString) {\n			octetStringBytes = ((DEROctetString) tagged).getOctets();\n		} else if (tagged instanceof DERPrintableString) {\n			octetStringBytes = ((DERPrintableString) tagged).getOctets();\n		} else {\n			return null;\n		}\n		return new String(octetStringBytes, StandardCharsets.UTF_8);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.assinatura.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.pdmodel.PDPageContentStream;\nimport org.apache.pdfbox.pdmodel.font.PDType0Font;\nimport org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\n\n@Service\n@RequiredArgsConstructor\npublic class SignatureLabelQrCodeService {\n	private final RuntimeConstants runtimeConstants;\n	private final GenerateQrCodeService generateQrCodeService;\n\n	public void applyQRCode(\n			PDDocument document,\n			PDPageContentStream contentStream,\n			String url\n	) throws IOException {\n		contentStream.saveGraphicsState();\n		val qrCode = generateQrCodeService.generateQrCode(url);\n		val inlineImage = PDImageXObject.createFromByteArray(document, qrCode, ""QRCode"");\n		contentStream.drawImage(inlineImage, 6f, 761f, 60f, 60f);\n		contentStream.restoreGraphicsState();\n	}\n\n	public void applyQrCodeAuxText(\n			PDPageContentStream contentStream,\n			String codigoAcesso,\n			PDType0Font font,\n			PDType0Font boldFont,\n			float fontSize\n	) throws IOException {\n		contentStream.showText(""Para retirar o(s) medicamento(s)"");\n		contentStream.newLine();\n		contentStream.showText(""apresente na farmácia o QR Code ou o"");\n		contentStream.newLine();\n		contentStream.showText(""código de acesso abaixo."");\n		contentStream.newLine();\n		contentStream.newLine();\n		contentStream.newLine();\n		contentStream.newLine();\n		contentStream.setFont(boldFont, fontSize);\n		contentStream.showText(""Código de acesso: "");\n		contentStream.setFont(font, fontSize);\n		contentStream.showText(codigoAcesso);\n		contentStream.newLine();\n		contentStream.newLine();\n		contentStream.showText(runtimeConstants.getPublicUri());\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.farmaceutico.service;\n\nimport java.util.Objects;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityUpdateService;\nimport br.ufsc.bridge.pecassinador.farmaceutico.dto.FarmaceuticoDto;\nimport br.ufsc.bridge.pecassinador.farmaceutico.mapper.FarmaceuticoMapper;\nimport br.ufsc.bridge.pecassinador.farmaceutico.model.Farmaceutico;\nimport br.ufsc.bridge.pecassinador.farmaceutico.repository.FarmaceuticoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\nimport jakarta.transaction.Transactional;\n\n@Service\n@RequiredArgsConstructor\npublic class FarmaceuticoUpdateService implements EntityUpdateService<FarmaceuticoDto> {\n\n	private final FarmaceuticoRepository repository;\n	private final FarmaceuticoMapper mapper;\n\n	@Override\n	@Transactional\n	public Long update(Long id, FarmaceuticoDto farmaceuticoDto) {\n		val oldFarmaceutico = this.repository.findById(id).orElseThrow(EntityNotFoundException::new);\n\n		if (detectUpdates(oldFarmaceutico, farmaceuticoDto)) {\n			val newFarmaceutico = this.mapper.update(farmaceuticoDto, oldFarmaceutico);\n			return this.repository.save(newFarmaceutico).getId();\n		}\n\n		return oldFarmaceutico.getId();\n	}\n\n	private boolean detectUpdates(Farmaceutico old, FarmaceuticoDto currentDto) {\n		val isNameChanged = !Objects.equals(old.getNome(), currentDto.getNome());\n		val isCrfChanged = currentDto.getCrf() != null && (old.getCrf() == null || !Objects.equals(old.getCrf(), currentDto.getCrf()));\n		val isUfConselhoChanged = currentDto.getUfConselhoClasse() != null && (old.getUfConselhoClasse() == null || !Objects.equals(old.getUfConselhoClasse().getId(),\n				currentDto.getUfConselhoClasse().getId()));\n\n		return isNameChanged || isCrfChanged || isUfConselhoChanged;\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.farmaceutico.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityGetOrCreateService;\nimport br.ufsc.bridge.pecassinador.farmaceutico.dto.FarmaceuticoDto;\nimport br.ufsc.bridge.pecassinador.farmaceutico.mapper.FarmaceuticoMapper;\nimport br.ufsc.bridge.pecassinador.farmaceutico.repository.FarmaceuticoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class FarmaceuticoGetOrCreateService implements EntityGetOrCreateService<FarmaceuticoDto> {\n\n	private final FarmaceuticoMapper mapper;\n	private final FarmaceuticoRepository repository;\n\n	@Transactional\n	public Long getOrCreate(FarmaceuticoDto farmaceuticoDto) {\n		return this.repository\n				.findByCpf(farmaceuticoDto.getCpf())\n				.orElseGet(() -> this.repository.save(this.mapper.toEntity(farmaceuticoDto)))\n				.getId();\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.farmaceutico.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.farmaceutico.dto.FarmaceuticoDto;\nimport br.ufsc.bridge.pecassinador.farmaceutico.mapper.FarmaceuticoMapper;\nimport br.ufsc.bridge.pecassinador.farmaceutico.repository.FarmaceuticoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class FarmaceuticoGetService {\n\n	private final FarmaceuticoRepository farmaceuticoRepository;\n	private final FarmaceuticoMapper mapper;\n\n	public FarmaceuticoDto getFarmaceutico(String cpf) {\n		return this.mapper.toDto(\n				this.farmaceuticoRepository\n						.findByCpf(cpf)\n						.orElse(null)\n		);\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.documento.latest.service;\n\nimport static java.time.LocalDateTime.now;\n\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.arquivo.model.Arquivo;\nimport br.ufsc.bridge.pecassinador.cidadao.latest.repository.CidadaoRepository;\nimport br.ufsc.bridge.pecassinador.cidadao.latest.service.CidadaoCreateService;\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\nimport br.ufsc.bridge.pecassinador.documento.common.model.Documento;\nimport br.ufsc.bridge.pecassinador.documento.common.model.DocumentoTemporario;\nimport br.ufsc.bridge.pecassinador.documento.common.model.TipoDocumento;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.documento.latest.mapper.DocumentoTemporarioMapper;\nimport br.ufsc.bridge.pecassinador.emissor.latest.repository.EmissorRepository;\nimport br.ufsc.bridge.pecassinador.emissor.latest.service.EmissorCreateService;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.service.ReceitaMedicamentoCreateService;\n\nimport jakarta.persistence.EntityManager;\n\n@Service\n@RequiredArgsConstructor\npublic class DocumentoCreateService implements EntityCreateService<DocumentoTemporario> {\n	private final DocumentoRepository documentoRepository;\n	private final EmissorRepository emissorRepository;\n	private final CidadaoRepository cidadaoRepository;\n	private final EmissorCreateService emissorCreateService;\n	private final CidadaoCreateService cidadaoCreateService;\n	private final DocumentoTemporarioMapper documentoTemporarioMapper;\n	private final ReceitaMedicamentoCreateService receitaMedicamentoCreateService;\n	private final EntityManager entityManager;\n\n	@Transactional\n	public Long create(DocumentoTemporario documentoTemporario) {\n		val documento = new Documento();\n\n		val emissorId = this.emissorCreateService.create(this.documentoTemporarioMapper.toEmissorDto(documentoTemporario));\n		val cidadaoId = this.cidadaoCreateService.create(this.documentoTemporarioMapper.toCidadaoDto(documentoTemporario));\n		val tipoDocumento = TipoDocumentoEnum.getById(documentoTemporario.getTipoDocumento().getId());\n\n		documento.setArquivo(getArquivo(documentoTemporario, tipoDocumento));\n		documento.setEmissor(this.emissorRepository.getReferenceById(emissorId));\n		documento.setCidadao(this.cidadaoRepository.getReferenceById(cidadaoId));\n		documento.setCodigoAcesso(documentoTemporario.getCodigoAcesso());\n		documento.setContaServico(documentoTemporario.getContaServico());\n		documento.setDataCriacao(documentoTemporario.getDataCriacao());\n		documento.setDataAssinatura(documentoTemporario.getDataAssinatura());\n		documento.setTipoDocumento(this.entityManager.getReference(TipoDocumento.class, tipoDocumento.getId()));\n		documento.setDataEmissao(now());\n		documento.setDataInicioAtendimento(documentoTemporario.getDataInicioAtendimento());\n\n		val documentoDatabaseId = this.documentoRepository.save(documento).getId();\n\n		Optional.ofNullable(this.documentoTemporarioMapper.toReceituario(documentoTemporario)).ifPresent(receituario -> {\n			receituario.forEach(receitaMedicamento -> {\n				this.receitaMedicamentoCreateService.create(receitaMedicamento, documentoDatabaseId);\n			});\n		});\n\n		return documentoDatabaseId;\n	}\n\n	private Arquivo getArquivo(DocumentoTemporario documentoTemporario, TipoDocumentoEnum tipoDocumento) {\n		return switch (tipoDocumento) {\n			case PRESCRICAO_COMUM, PRESCRICAO_CONTROLADA -> documentoTemporario.getArquivo();\n			case ATESTADO -> null;\n		};\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.documento.latest.service;\n\nimport java.io.IOException;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.arquivo.service.ArquivoCreateService;\nimport br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum;\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\nimport br.ufsc.bridge.pecassinador.documento.latest.dto.DocumentoTemporarioCreateDto;\nimport br.ufsc.bridge.pecassinador.documento.latest.dto.DocumentoTemporarioCreateResponseDto;\nimport br.ufsc.bridge.pecassinador.documento.latest.mapper.DocumentoTemporarioMapper;\n\n@Service\n@RequiredArgsConstructor\npublic class DocumentoTemporarioCreateService {\n	private final ArquivoCreateService arquivoCreateService;\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final DocumentoTemporarioMapper documentoTemporarioMapper;\n\n	@Transactional\n	public DocumentoTemporarioCreateResponseDto create(DocumentoTemporarioCreateDto documentoTemporarioCreateDto) throws IOException {\n		try {\n			val prescritorDto = documentoTemporarioCreateDto.getPrescritor();\n			val hasConselho = !StringUtils.isAnyBlank(\n					prescritorDto.getSiglaConselhoClasse(),\n					prescritorDto.getNumeroConselhoClasse(),\n					prescritorDto.getUfEmissoraConselhoClasse()\n			);\n\n			if (!hasConselho) {\n				throw new SignatureException(SignatureErrorEnum.PROFISSIONAL_SEM_CONSELHO);\n			}\n		} catch (SignatureException e) {\n			return new DocumentoTemporarioCreateResponseDto(\n					this.buildUrlErro(\n							documentoTemporarioCreateDto.getContaServicoName(),\n							SignatureErrorEnum.getById(e.getCode())\n					)\n			);\n		}\n\n		val documentoTemporario = this.documentoTemporarioMapper.documentoTemporarioCreateDtoToEntity(documentoTemporarioCreateDto);\n		String nomeCidadao = documentoTemporarioCreateDto.getCidadao().getNomeSocial() != null ?\n				documentoTemporarioCreateDto.getCidadao().getNomeSocial() :\n				documentoTemporarioCreateDto.getCidadao().getNome();\n		LocalDate dataDocumento = documentoTemporarioCreateDto.getDataInicioAtendimento() != null ?\n				documentoTemporarioCreateDto.getDataInicioAtendimento() :\n				LocalDate.now();\n		val arquivo = this.arquivoCreateService.create(\n				this.buildFilename(\n						nomeCidadao,\n						documentoTemporarioCreateDto.getTipoDocumento(),\n						dataDocumento\n				),\n				documentoTemporarioCreateDto.getPdf()\n		);\n\n		documentoTemporario.setArquivo(arquivo);\n\n		val documentoTemporarioId = this.documentoTemporarioRepository.save(documentoTemporario).getId();\n		val urlAssinarDocumento = this.buildUrlAssinarDocumento(\n				documentoTemporarioId,\n				documentoTemporarioCreateDto.getContaServicoName(),\n				documentoTemporarioCreateDto.getPrescritor().getCpf(),\n				documentoTemporarioCreateDto.getTipoDocumento()\n		);\n\n		return new DocumentoTemporarioCreateResponseDto(urlAssinarDocumento);\n	}\n\n	private String buildUrlAssinarDocumento(Long documentoId, String clientId, String cpf, TipoDocumentoEnum tipoDocumento) {\n\n		String baseUri = switch (tipoDocumento) {\n			case ATESTADO -> ""/api/v1/atestados/{documentoId}/assinar"";\n			case PRESCRICAO_COMUM -> ""/api/v1/prescricoes/{documentoId}/assinar"";\n			case PRESCRICAO_CONTROLADA -> ""/api/v1/prescricoes-controladas/{documentoId}/assinar"";\n		};\n\n		return UriComponentsBuilder\n				.fromUriString(baseUri)\n				.queryParam(""clientId"", clientId)\n				.queryParam(""cpf"", cpf)\n				.buildAndExpand(documentoId)\n				.toUriString();\n	}\n\n	private String buildUrlErro(String clientId, SignatureErrorEnum error) {\n		return UriComponentsBuilder\n				.fromUriString(""/api/v1/contas-servico/callback"")\n				.queryParam(""clientId"", clientId)\n				.queryParam(""error"", error.getId())\n				.build()\n				.toUriString();\n	}\n\n	private String buildFilename(String nomeCidadao, TipoDocumentoEnum tipoDocumento, LocalDate dataDocumento) {\n		String formattedDate = dataDocumento.format(DateTimeFormatter.ofPattern(""dd-MM-yyyy""));\n\n		String nameWithoutAccents = StringUtils.stripAccents(nomeCidadao).toLowerCase();\n		String formattedName = nameWithoutAccents.replace("" "", ""_"").replaceAll(""[^a-z0-9_ ]"", """");\n\n		return switch (tipoDocumento) {\n			case ATESTADO -> String.format(""atestado_%s_%s.pdf"", formattedName, formattedDate);\n			case PRESCRICAO_COMUM -> String.format(""prescricao_%s_%s.pdf"", formattedName, formattedDate);\n			case PRESCRICAO_CONTROLADA -> String.format(""prescricao_controlada_%s_%s.pdf"", formattedName, formattedDate);\n		};\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.documento.common.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.arquivo.service.ArquivoDeleteService;\nimport br.ufsc.bridge.pecassinador.documento.common.model.DocumentoTemporario;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class DocumentoTemporarioDeleteService {\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final ArquivoDeleteService arquivoDeleteService;\n\n	@Transactional\n	public void deleteFully(DocumentoTemporario documentoTemporario) throws IOException {\n		this.deleteEntity(documentoTemporario);\n		this.arquivoDeleteService.delete(documentoTemporario.getArquivo());\n	}\n\n	@Transactional\n	public void deleteEntity(DocumentoTemporario documentoTemporario) {\n		this.documentoTemporarioRepository.delete(documentoTemporario);\n	}\n\n}\n
service,"package br.ufsc.bridge.pecassinador.documento.common.service;\n\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.Collection;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.model.DocumentoTemporario;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class DocumentoTemporarioDeleteJobService {\n	private static final long SCHEDULE_DELAY_IN_MILLIS = 60_000;\n	private static final int PAGE_SIZE = 1000;\n	private static final long DOCUMENTO_TEMPORARIO_MAX_AGE_IN_MINUTES = 60;\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final DocumentoTemporarioDeleteService documentoTemporarioDeleteService;\n\n	@Scheduled(fixedDelay = SCHEDULE_DELAY_IN_MILLIS)\n	public void checkPendingDeletion() {\n		Page<DocumentoTemporario> documentoTemporarioPage;\n		do {\n			val pageable = PageRequest.of(0, PAGE_SIZE);\n			val timeLimit = LocalDateTime.now().minusMinutes(DOCUMENTO_TEMPORARIO_MAX_AGE_IN_MINUTES);\n			documentoTemporarioPage = this.documentoTemporarioRepository.findAllPendingDeletion(timeLimit, pageable);\n			this.deleteDocumentos(documentoTemporarioPage.getContent());\n		} while (!documentoTemporarioPage.isLast());\n	}\n\n	private void deleteDocumentos(Collection<DocumentoTemporario> documentos) {\n		for (DocumentoTemporario documento : documentos) {\n			try {\n				this.documentoTemporarioDeleteService.deleteFully(documento);\n			} catch (IOException e) {\n				log.error(""Não foi possível remover o documento temporário {}"", documento.getId(), e);\n			}\n		}\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.documento.common.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class TipoDocumentoGetService {\n\n	private final DocumentoRepository documentoRepository;\n\n	public TipoDocumentoEnum get(String codigoAcesso) {\n		val idTipoDocumento = this.documentoRepository.findByCodigoAcesso(codigoAcesso)\n				.orElseThrow(EntityNotFoundException::new)\n				.getTipoDocumento().getId();\n\n		return TipoDocumentoEnum.getById(idTipoDocumento);\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.documento.common.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.fornecimento.repository.FornecimentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class FornecimentoExistsService {\n	private final FornecimentoRepository fornecimentoRepository;\n\n	public boolean exists(String codigoAcesso, Long fornecimentoId) {\n		return this.fornecimentoRepository.existsByCodigoAcessoAndId(codigoAcesso, fornecimentoId);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.documento.v1.service;\n\nimport java.io.IOException;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.arquivo.service.ArquivoCreateService;\nimport br.ufsc.bridge.pecassinador.assinatura.enums.SignatureErrorEnum;\nimport br.ufsc.bridge.pecassinador.assinatura.exception.SignatureException;\nimport br.ufsc.bridge.pecassinador.documento.common.enums.TipoDocumentoEnum;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\nimport br.ufsc.bridge.pecassinador.documento.v1.dto.V1DocumentoTemporarioCreateDto;\nimport br.ufsc.bridge.pecassinador.documento.v1.dto.V1DocumentoTemporarioCreateResponseDto;\nimport br.ufsc.bridge.pecassinador.documento.v1.mapper.V1DocumentoTemporarioMapper;\n\n@Service\n@RequiredArgsConstructor\npublic class V1DocumentoTemporarioCreateService {\n	private final ArquivoCreateService arquivoCreateService;\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final V1DocumentoTemporarioMapper documentoTemporarioMapper;\n\n	@Transactional\n	public V1DocumentoTemporarioCreateResponseDto create(V1DocumentoTemporarioCreateDto documentoTemporarioCreateDto) throws IOException {\n		try {\n			val prescritorDto = documentoTemporarioCreateDto.getPrescritor();\n			val hasConselho = !StringUtils.isAnyBlank(\n					prescritorDto.getSiglaConselhoClasse(),\n					prescritorDto.getNumeroConselhoClasse(),\n					prescritorDto.getUfEmissoraConselhoClasse()\n			);\n\n			if (!hasConselho) {\n				throw new SignatureException(SignatureErrorEnum.PROFISSIONAL_SEM_CONSELHO);\n			}\n		} catch (SignatureException e) {\n			return new V1DocumentoTemporarioCreateResponseDto(\n					this.buildUrlErro(\n							documentoTemporarioCreateDto.getContaServicoName(),\n							SignatureErrorEnum.getById(e.getCode())\n					)\n			);\n		}\n\n		val documentoTemporario = this.documentoTemporarioMapper.documentoTemporarioCreateDtoToEntity(documentoTemporarioCreateDto);\n		val arquivo = this.arquivoCreateService.create(\n				this.buildFilename(\n						documentoTemporarioCreateDto.getCidadao().getNome(),\n						documentoTemporarioCreateDto.getTipoDocumento()\n				),\n				documentoTemporarioCreateDto.getPdf()\n		);\n\n		documentoTemporario.setArquivo(arquivo);\n\n		val documentoTemporarioId = this.documentoTemporarioRepository.save(documentoTemporario).getId();\n		val urlAssinarDocumento = this.buildUrlAssinarDocumento(\n				documentoTemporarioId,\n				documentoTemporarioCreateDto.getContaServicoName(),\n				documentoTemporarioCreateDto.getPrescritor().getCpf(),\n				documentoTemporarioCreateDto.getTipoDocumento()\n		);\n\n		return new V1DocumentoTemporarioCreateResponseDto(urlAssinarDocumento);\n	}\n\n	private String buildUrlAssinarDocumento(Long documentoId, String clientId, String cpf, TipoDocumentoEnum tipoDocumento) {\n\n		String baseUri = switch (tipoDocumento) {\n			case ATESTADO -> ""/api/v1/atestados/{documentoId}/assinar"";\n			case PRESCRICAO_COMUM -> ""/api/v1/prescricoes/{documentoId}/assinar"";\n			case PRESCRICAO_CONTROLADA -> ""/api/v1/prescricoes-controladas/{documentoId}/assinar"";\n		};\n\n		return UriComponentsBuilder\n				.fromUriString(baseUri)\n				.queryParam(""clientId"", clientId)\n				.queryParam(""cpf"", cpf)\n				.buildAndExpand(documentoId)\n				.toUriString();\n	}\n\n	private String buildUrlErro(String clientId, SignatureErrorEnum error) {\n		return UriComponentsBuilder\n				.fromUriString(""/api/v1/contas-servico/callback"")\n				.queryParam(""clientId"", clientId)\n				.queryParam(""error"", error.getId())\n				.build()\n				.toUriString();\n	}\n\n	private String buildFilename(String nomeCidadao, TipoDocumentoEnum tipoDocumento) {\n		LocalDate currentDate = LocalDate.now();\n		String formattedDate = currentDate.format(DateTimeFormatter.ofPattern(""dd-MM-yyyy""));\n\n		String nameWithoutAccents = StringUtils.stripAccents(nomeCidadao).toLowerCase();\n		String formattedName = nameWithoutAccents.replace("" "", ""_"").replaceAll(""[^a-z0-9_ ]"", """");\n\n		return switch (tipoDocumento) {\n			case ATESTADO -> String.format(""atestado_%s_%s.pdf"", formattedName, formattedDate);\n			case PRESCRICAO_COMUM -> String.format(""prescricao_%s_%s.pdf"", formattedName, formattedDate);\n			case PRESCRICAO_CONTROLADA -> String.format(""prescricao_controlada_%s_%s.pdf"", formattedName, formattedDate);\n		};\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.receitamedicamento.latest.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityGetOrCreateService;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.dto.MedicamentoDto;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.mapper.MedicamentoMapper;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.repository.MedicamentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class MedicamentoGetOrCreateService implements EntityGetOrCreateService<MedicamentoDto> {\n	private final MedicamentoRepository medicamentoRepository;\n	private final MedicamentoMapper medicamentoMapper;\n\n	public Long getOrCreate(MedicamentoDto dto) {\n		Long categoriaMedicamentoId = dto.getCategoriaMedicamento() != null ? dto.getCategoriaMedicamento().getId() : null;\n\n		return this.medicamentoRepository.findMedicamento(\n						dto.getPrincipioAtivo(),\n						dto.getConcentracao(),\n						dto.getFormaFarmaceutica(),\n						dto.getUnidadeFornecimento(),\n						categoriaMedicamentoId,\n						dto.getCodigoCatMat()\n				).orElseGet(() -> this.medicamentoRepository.save(this.medicamentoMapper.toEntity(dto)))\n				.getId();\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.receitamedicamento.latest.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.dto.ReceitaMedicamentoDto;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.mapper.ReceitaMedicamentoMapper;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.repository.MedicamentoRepository;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.repository.ReceitaMedicamentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ReceitaMedicamentoCreateService {\n\n	private final ReceitaMedicamentoRepository repository;\n	private final ReceitaMedicamentoMapper mapper;\n	private final MedicamentoRepository medicamentoRepository;\n	private final MedicamentoGetOrCreateService medicamentoGetOrCreateService;\n	private final DocumentoRepository documentoRepository;\n\n	public Long create(\n			ReceitaMedicamentoDto receitaMedicamentoDto,\n			Long documentoId\n	) {\n		val receitaMedicamento = this.mapper.toEntity(receitaMedicamentoDto);\n		receitaMedicamento.setDocumento(this.documentoRepository.getReferenceById(documentoId));\n		receitaMedicamento.setMedicamento(\n				this.medicamentoRepository.getReferenceById(this.medicamentoGetOrCreateService.getOrCreate(receitaMedicamentoDto.getMedicamento()))\n		);\n\n		return this.repository.save(receitaMedicamento).getId();\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.receitamedicamento.common.service;\n\nimport java.util.List;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.receitamedicamento.common.mapper.ReceitaMedicamentoQueryDtoMapper;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.dto.ReceitaMedicamentoDto;\nimport br.ufsc.bridge.pecassinador.receitamedicamento.latest.repository.ReceitaMedicamentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ReceitaMedicamentoListService {\n	private final ReceitaMedicamentoRepository receitaMedicamentoRepository;\n	private final ReceitaMedicamentoQueryDtoMapper mapper;\n\n	public List<ReceitaMedicamentoDto> getReceitaMedicamentos(String codigoAcesso) {\n		val receitaMedicamentos = this.receitaMedicamentoRepository.findAllByCodigoAcessoDocumento(codigoAcesso);\n		return this.mapper.toDto(receitaMedicamentos);\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.security.authorization.service;\n\nimport java.util.List;\nimport java.util.stream.Stream;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.security.authorization.dto.AuthorizationProviderDto;\nimport br.ufsc.bridge.pecassinador.security.integraicp.service.IntegraIcpListProvidersService;\n\nimport jakarta.servlet.http.HttpServletRequest;\n\n@Service\n@RequiredArgsConstructor\npublic class AuthorizationListProvidersService {\n	private final IntegraIcpListProvidersService integraIcpListProvidersService;\n\n	public List<AuthorizationProviderDto> getProviders(Boolean isQualified, HttpServletRequest request) {\n		val integraIcpProviders = this.integraIcpListProvidersService.getProviders(request);\n\n		return Boolean.TRUE.equals(isQualified)\n				? integraIcpProviders.toList()\n				: Stream.concat(Stream.of(new AuthorizationProviderDto(""Gov.br"", ""/api/oauth2/authorization/govbr"")), integraIcpProviders).toList();\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.authorization.service;\n\nimport static br.ufsc.bridge.pecassinador.security.secured.SecuredScope.GOVBR;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\nimport br.ufsc.bridge.pecassinador.security.secured.SecuredContext;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\n@Service\n@RequiredArgsConstructor\npublic class AuthorizationUnauthorizeService {\n	private final RuntimeConstants runtimeConstants;\n\n	public void unauthorize(HttpServletRequest request, HttpServletResponse response, SecuredContext securedContext) throws IOException {\n		request.getSession(false).invalidate();\n		if (securedContext.getScopes().contains(GOVBR)) {\n			val iss = securedContext.getAttributes().get(""iss"");\n			val logoutUrl = iss + ""logout?post_logout_redirect_uri="" + this.runtimeConstants.getPublicUri();\n			response.sendRedirect(logoutUrl);\n			return;\n		}\n		response.setStatus(HttpStatus.OK.value());\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.oauth;\n\nimport static br.ufsc.bridge.pecassinador.security.secured.SecuredContext.CREDENTIALS_ATTRIBUTE;\nimport static br.ufsc.bridge.pecassinador.security.secured.SecuredScope.SIGN;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextImpl;\nimport org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;\nimport org.springframework.security.oauth2.client.userinfo.DefaultOAuth2UserService;\nimport org.springframework.security.oauth2.client.userinfo.OAuth2UserRequest;\nimport org.springframework.security.oauth2.core.OAuth2AuthenticationException;\nimport org.springframework.security.oauth2.core.user.OAuth2User;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.security.authorization.dto.CredentialsDto;\n\nimport jakarta.servlet.http.HttpServletRequest;\n\n@Service\n@RequiredArgsConstructor\n//govbr não usa essa classe porque tem scope openid\npublic class CustomOAuth2UserService extends DefaultOAuth2UserService {\n	private final HttpServletRequest httpServletRequest;\n\n	@Override\n	public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {\n		val securedContext = (SecurityContextImpl) this.httpServletRequest.getSession(false).getAttribute(""SPRING_SECURITY_CONTEXT"");\n		val oldToken = (OAuth2AuthenticationToken) securedContext.getAuthentication();\n\n		val tokenBuilder = OAuth2AuthenticationTokenBuilder.fromToken(oldToken);\n		val credentials = new CredentialsDto(userRequest.getAccessToken().getTokenValue(), null, null);\n		tokenBuilder.putAttribute(CREDENTIALS_ATTRIBUTE, credentials);\n		tokenBuilder.putAuthorities(new SimpleGrantedAuthority(SIGN));\n\n		return tokenBuilder.build().getPrincipal();\n	}\n\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.contaservico;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.oauth2.core.user.OAuth2User;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.contaservico.dto.ContaServicoLoginRequestDto;\n\nimport jakarta.servlet.http.HttpServletResponse;\n\n@Service\n@RequiredArgsConstructor\npublic class ContaServicoLoginService {\n	private final ContaServicoJwtService contaServicoJwtService;\n	private final AuthenticationConfiguration authenticationConfiguration;\n\n	public void login(ContaServicoLoginRequestDto contaServicoLoginRequestDto, HttpServletResponse response) throws Exception {\n		val authentication = this.authenticationConfiguration\n				.getAuthenticationManager()\n				.authenticate(new ContaServicoAuthenticationToken(contaServicoLoginRequestDto.getClientId(), contaServicoLoginRequestDto.getSecret()));\n\n		val token = this.contaServicoJwtService.createToken((OAuth2User) authentication.getPrincipal());\n\n		response.setHeader(HttpHeaders.AUTHORIZATION, token);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.contaservico;\n\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.List;\nimport java.util.Map;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.oauth2.core.user.DefaultOAuth2User;\nimport org.springframework.security.oauth2.core.user.OAuth2User;\nimport org.springframework.security.oauth2.jwt.JwtException;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.security.secured.SecuredScope;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.auth0.jwt.interfaces.DecodedJWT;\n\n@Service\n@RequiredArgsConstructor\npublic class ContaServicoJwtService {\n	@Value(""${conta-servico.jwt-secret}"")\n	private String secret;\n	@Value(""${conta-servico.jwt-expiration-minutes}"")\n	private long expiration;\n\n	public String createToken(OAuth2User user) {\n		return JWT.create()\n				.withExpiresAt(Instant.now().plus(this.expiration, ChronoUnit.MINUTES))\n				.withClaim(""sub"", (String) user.getAttribute(""sub""))\n				.withClaim(""id"", (Long) user.getAttribute(""id""))\n				.withClaim(""redirectUri"", (String) user.getAttribute(""redirectUri""))\n				.withArrayClaim(""scopes"", new String[] { SecuredScope.SERVICE })\n				.sign(Algorithm.HMAC512(this.secret.getBytes()));\n	}\n\n	public OAuth2User decodeToken(String token) {\n		val payload = this.verifyToken(token);\n\n		if (payload == null) {\n			throw new JwtException(""JWT decoding error"");\n		}\n\n		val attributes = Map.of(\n				""sub"", payload.getClaim(""sub"").asString(),\n				""id"", (Object) payload.getClaim(""id"").asLong(),\n				""redirectUri"", payload.getClaim(""redirectUri"").asString());\n\n		val authorities = List.of(new SimpleGrantedAuthority(SecuredScope.SERVICE));\n		return new DefaultOAuth2User(authorities, attributes, ""sub"");\n	}\n\n	private DecodedJWT verifyToken(String token) {\n		return JWT\n				.require(Algorithm.HMAC512(this.secret.getBytes()))\n				.build()\n				.verify(token);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.integraicp.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.web.authentication.AuthenticationSuccessHandler;\nimport org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.common.exception.AuthorizationException;\nimport br.ufsc.bridge.pecassinador.security.authorization.dto.CredentialsDto;\nimport br.ufsc.bridge.pecassinador.security.integraicp.dto.IntegraIcpAuthenticationToken;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\n@Service\n@RequiredArgsConstructor\npublic class IntegraIcpAuthenticateService {\n	private static final String INTEGRA_ICP_VERIFIER_ATTRIBUTE = ""INTEGRA_ICP_VERIFIER"";\n	private final AuthenticationConfiguration authenticationConfiguration;\n	private final AuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();\n\n	public void authenticate(String code, HttpServletRequest request, HttpServletResponse response) {\n		val verifier = (String) request.getSession(false).getAttribute(INTEGRA_ICP_VERIFIER_ATTRIBUTE);\n		val credentialsDto = new CredentialsDto(code, verifier, null);\n		Authentication authentication = null;\n\n		try {\n			authentication = this.authenticationConfiguration.getAuthenticationManager().authenticate(new IntegraIcpAuthenticationToken(credentialsDto.code(), credentialsDto));\n			this.successHandler.onAuthenticationSuccess(request, response, authentication);\n		} catch (Exception ex) {\n			throw new AuthorizationException(""Falha na autenticação do Integra ICP"", ex);\n		}\n\n		SecurityContextHolder.getContext().setAuthentication(authentication);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.integraicp.service;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\nimport java.util.Base64;\nimport java.util.stream.Stream;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport lombok.val;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.security.crypto.keygen.Base64StringKeyGenerator;\nimport org.springframework.security.crypto.keygen.StringKeyGenerator;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\nimport br.ufsc.bridge.pecassinador.security.authorization.dto.AuthorizationProviderDto;\nimport br.ufsc.bridge.pecassinador.security.integraicp.IntegraIcpConstants;\nimport br.ufsc.bridge.pecassinador.security.integraicp.dto.IntegraIcpAuthenticationsResponseDto;\n\nimport jakarta.servlet.http.HttpServletRequest;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class IntegraIcpListProvidersService {\n	private static final String INTEGRA_ICP_VERIFIER_ATTRIBUTE = ""INTEGRA_ICP_VERIFIER"";\n	private static final String INTEGRA_ICP_CHANNEL = ""99a8fe78-bde4-491b-8c6a-1b0d2969fd2a"";\n	private static final String INTEGRA_ICP_BASE_API = ""https://services.integraicp.com.br/v3"";\n\n	private final RuntimeConstants runtimeConstants;\n	private final StringKeyGenerator secureKeyGenerator = new Base64StringKeyGenerator(Base64.getUrlEncoder().withoutPadding(), 96);\n\n	public Stream<AuthorizationProviderDto> getProviders(HttpServletRequest request) {\n		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n		int timeout = (int) IntegraIcpConstants.PROVIDERS_REQUEST_TIMEOUT.toMillis();\n\n		requestFactory.setConnectTimeout(timeout);\n		requestFactory.setReadTimeout(timeout);\n\n		val restTemplate = new RestTemplate(requestFactory);\n		val verifier = this.secureKeyGenerator.generateKey();\n\n		request.getSession(true).setAttribute(INTEGRA_ICP_VERIFIER_ATTRIBUTE, verifier);\n\n		val urlBuilder = UriComponentsBuilder\n				.fromUriString(""{baseApi}/authentications/{channel}"")\n				.queryParam(""redirect_uri"", this.runtimeConstants.getPublicUri() + ""/api/integraicp/callback"")\n				.queryParam(""code_challenge"", this.createHash(verifier));\n\n		val uri = urlBuilder.buildAndExpand(INTEGRA_ICP_BASE_API, INTEGRA_ICP_CHANNEL).toUriString();\n		try {\n			val response = restTemplate.getForEntity(uri, IntegraIcpAuthenticationsResponseDto.class);\n\n			if (response.getStatusCode().is2xxSuccessful()) {\n				return response.getBody().data().clearances()\n						.stream()\n						.map(this::toAuthorizationProviderDto);\n			}\n\n		} catch (Exception ignored) {\n		}\n\n		return Stream.empty();\n	}\n\n	private AuthorizationProviderDto toAuthorizationProviderDto(IntegraIcpAuthenticationsResponseDto.ClearanceDto clearenceDto) {\n		return new AuthorizationProviderDto(clearenceDto.productName(), clearenceDto.clearanceEndpoint());\n	}\n\n	private String createHash(String value) {\n		val digest = DigestUtils.sha256(value.getBytes(US_ASCII));\n		return Base64.getUrlEncoder().withoutPadding().encodeToString(digest);\n	}\n\n}\n"
service,"package br.ufsc.bridge.pecassinador.security.integraicp.service;\n\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.security.authorization.dto.CredentialsDto;\nimport br.ufsc.bridge.pecassinador.security.integraicp.dto.IntegraIcpGetCredentialsResponseDto;\n\n@Service\npublic class IntegraIcpAuthenticationService {\n	private static final String INTEGRA_ICP_BASE_API = ""https://services.integraicp.com.br/v3"";\n\n	public IntegraIcpGetCredentialsResponseDto getCredentials(CredentialsDto credentialsDto) {\n		val restTemplate = new RestTemplate();\n\n		val url = UriComponentsBuilder\n				.fromUriString(""{baseApi}/credentials/{code}"")\n				.queryParam(""code_verifier"", credentialsDto.verifier())\n				.buildAndExpand(INTEGRA_ICP_BASE_API, credentialsDto.code())\n				.toUriString();\n\n		val response = restTemplate.getForEntity(url, IntegraIcpGetCredentialsResponseDto.class);\n\n		if (!response.getStatusCode().is2xxSuccessful()) {\n			return null;\n		}\n\n		return response.getBody();\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.emissor.latest.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityGetOrCreateService;\nimport br.ufsc.bridge.pecassinador.emissor.latest.dto.CboDto;\nimport br.ufsc.bridge.pecassinador.emissor.latest.mapper.CboMapper;\nimport br.ufsc.bridge.pecassinador.emissor.latest.repository.CboRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class CboGetOrCreateService implements EntityGetOrCreateService<CboDto> {\n	private final CboRepository cboRepository;\n	private final CboMapper cboMapper;\n\n	@Transactional\n	public Long getOrCreate(CboDto cbo) {\n		return this.cboRepository\n				.findByCodigoCbo2002(cbo.getCodigoCbo2002())\n				.orElseGet(() -> this.cboRepository.save(this.cboMapper.toEntity(cbo))).getId();\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.emissor.latest.service;\n\nimport java.util.Optional;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.common.data.EntityCreateService;\nimport br.ufsc.bridge.pecassinador.emissor.latest.dto.CboDto;\nimport br.ufsc.bridge.pecassinador.emissor.latest.dto.EmissorDto;\nimport br.ufsc.bridge.pecassinador.emissor.latest.mapper.EmissorMapper;\nimport br.ufsc.bridge.pecassinador.emissor.latest.repository.CboRepository;\nimport br.ufsc.bridge.pecassinador.emissor.latest.repository.EmissorRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class EmissorCreateService implements EntityCreateService<EmissorDto> {\n\n	private final EmissorRepository emissorRepository;\n	private final EmissorMapper mapper;\n	private final CboGetOrCreateService cboCreateService;\n	private final CboRepository cboRepository;\n\n	@Transactional\n	public Long create(EmissorDto emissorDto) {\n		val emissor = this.mapper.toEntity(emissorDto);\n\n		Optional.ofNullable(emissorDto.getCbo())\n				.map(CboDto::getCodigoCbo2002)\n				.ifPresent(codigoCbo ->\n						emissor.setCbo(this.cboRepository.getReferenceById(this.cboCreateService.getOrCreate(emissorDto.getCbo())))\n				);\n\n		return this.emissorRepository.save(emissor).getId();\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.prescricao.latest.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\nimport br.ufsc.bridge.pecassinador.documento.common.model.DocumentoTemporario;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoTemporarioRepository;\nimport br.ufsc.bridge.pecassinador.documento.common.service.DocumentoTemporarioDeleteService;\nimport br.ufsc.bridge.pecassinador.documento.latest.service.DocumentoCreateService;\nimport br.ufsc.bridge.pecassinador.prescricao.latest.dto.PrescricaoEmitResponseDto;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class PrescricaoEmitService {\n	private final RuntimeConstants runtimeConstants;\n	private final DocumentoTemporarioRepository documentoTemporarioRepository;\n	private final DocumentoCreateService documentoCreateService;\n	private final DocumentoRepository documentoRepository;\n	private final DocumentoTemporarioDeleteService documentoTemporarioDeleteService;\n\n	@Transactional\n	public PrescricaoEmitResponseDto emit(String codigoAcesso, Long contaServicoId) {\n		DocumentoTemporario documentoTemporario = documentoTemporarioRepository.findByCodigoAcessoAndContaServicoIdWithDataAssinatura(codigoAcesso, contaServicoId)\n				.orElseThrow(EntityNotFoundException::new);\n		val documentoCreatedId = this.documentoCreateService.create(documentoTemporario);\n\n		this.documentoTemporarioDeleteService.deleteEntity(documentoTemporario);\n\n		return new PrescricaoEmitResponseDto(this.buildUrlAcessoPrescricao(\n				this.documentoRepository.getReferenceById(documentoCreatedId).getCodigoAcesso()\n		));\n	}\n\n	private String buildUrlAcessoPrescricao(String codigoAcesso) {\n		return UriComponentsBuilder\n				.fromUriString(""{publicUri}/prescricoes/{codigoAcesso}"")\n				.buildAndExpand(this.runtimeConstants.getPublicUri(), codigoAcesso)\n				.toUriString();\n	}\n\n}\n"
service,"package br.ufsc.bridge.pecassinador.prescricao.latest.service;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.auditoria.enums.AuditoriaEventoEnum;\nimport br.ufsc.bridge.pecassinador.auditoria.service.AuditoriaEventoCreateService;\nimport br.ufsc.bridge.pecassinador.common.exception.AccessException;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class PrescricaoDeleteService {\n\n	private final DocumentoRepository repository;\n	private final AuditoriaEventoCreateService auditoriaEventoCreateService;\n\n	@Transactional\n	public void delete(String codigoAcesso, String nomeContaServico) throws EntityNotFoundException, AccessException {\n		val expectedNomeContaServico = this.repository\n				.getNomeContaServicoByCodigoAcesso(codigoAcesso)\n				.orElseThrow(EntityNotFoundException::new);\n		if (!expectedNomeContaServico.equals(nomeContaServico)) {\n			throw new AccessException(""Nome da conta serviço diferente do esperado"");\n		}\n		this.auditoriaEventoCreateService.create(codigoAcesso, AuditoriaEventoEnum.INVALIDAR_PRESCRICAO);\n		this.repository.deleteByCodigoAcesso(codigoAcesso);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.prescricao.latest.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.assinatura.service.DocumentoReadFileService;\nimport br.ufsc.bridge.pecassinador.auditoria.enums.AuditoriaEventoEnum;\nimport br.ufsc.bridge.pecassinador.auditoria.service.AuditoriaEventoCreateService;\nimport br.ufsc.bridge.pecassinador.common.util.ResponseUtils;\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class PrescricaoDownloadService {\n	private final DocumentoRepository documentoRepository;\n	private final DocumentoReadFileService documentoReadFileService;\n	private final AuditoriaEventoCreateService auditoriaEventoCreateService;\n\n	public ResponseEntity<ByteArrayResource> download(String codigoAcesso) throws IOException {\n		val arquivo = this.documentoRepository\n				.findArquivoByCodigoAcesso(codigoAcesso)\n				.orElseThrow(EntityNotFoundException::new);\n\n		val data = this.documentoReadFileService.read(arquivo);\n		this.auditoriaEventoCreateService.create(codigoAcesso, AuditoriaEventoEnum.ACESSO_PRESCRICAO);\n\n		return ResponseUtils.downloadPdf(data, arquivo.getNome());\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.prescricao.common.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\nimport br.ufsc.bridge.pecassinador.prescricao.common.dto.PrescricaoDto;\nimport br.ufsc.bridge.pecassinador.prescricao.latest.mapper.PrescricaoMapper;\n\nimport jakarta.persistence.EntityNotFoundException;\n\n@Service\n@RequiredArgsConstructor\npublic class PrescricaoGetService {\n	private final DocumentoRepository documentoRepository;\n	private final PrescricaoMapper mapper;\n\n	public PrescricaoDto get(String codigoAcesso) {\n		return this.mapper.toDto(\n				this.documentoRepository\n						.findByCodigoAcesso(codigoAcesso)\n						.orElseThrow(EntityNotFoundException::new)\n		);\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.prescricao.common.service;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.documento.common.repository.DocumentoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class PrescricaoExistsService {\n	private final DocumentoRepository documentoRepository;\n\n	public boolean exists(String codigoAcesso) {\n		return this.documentoRepository.existsByCodigoAcesso(codigoAcesso);\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.contaservico.service;\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport br.ufsc.bridge.pecassinador.contaservico.repository.ContaServicoRepository;\n\nimport jakarta.persistence.EntityNotFoundException;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\n@Service\n@RequiredArgsConstructor\npublic class ContaServicoCallbackService {\n	private final ContaServicoRepository contaServicoRepository;\n\n	public void callback(HttpServletRequest request, HttpServletResponse response) throws IOException {\n		val clientId = request.getParameter(""clientId"");\n\n		val baseRedirectUri = this.contaServicoRepository\n				.getRedirectUriByNome(clientId)\n				.orElseThrow(EntityNotFoundException::new);\n\n		val requestMap = request.getParameterMap();\n		val responseMap = new LinkedMultiValueMap<String, String>();\n\n		requestMap.forEach((key, value) -> responseMap.put(key, Arrays.asList(value)));\n\n		val redirectUrl = UriComponentsBuilder\n				.fromUriString(baseRedirectUri)\n				.queryParams(responseMap)\n				.build()\n				.toUriString();\n\n		response.sendRedirect(redirectUrl);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.contaservico.service;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\nimport javax.crypto.KeyGenerator;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport br.ufsc.bridge.pecassinador.contaservico.dto.ContaServicoCreateRequestDto;\nimport br.ufsc.bridge.pecassinador.contaservico.dto.ContaServicoDto;\nimport br.ufsc.bridge.pecassinador.contaservico.mapper.ContaServicoMapper;\nimport br.ufsc.bridge.pecassinador.contaservico.repository.ContaServicoRepository;\n\n@Service\n@RequiredArgsConstructor\npublic class ContaServicoCreateService {\n	private final ContaServicoRepository contaServicoRepository;\n	private final ContaServicoMapper contaServicoMapper;\n\n	@Transactional\n	public ContaServicoDto create(ContaServicoCreateRequestDto requestDto) throws NoSuchAlgorithmException {\n		requestDto.setClientSecret(this.generatePassword());\n		val contaServico = this.contaServicoRepository.save(this.contaServicoMapper.toEntity(requestDto));\n		val contaServicoDto = this.contaServicoMapper.toDto(contaServico);\n		contaServicoDto.setClientSecret(requestDto.getClientSecret());\n\n		return contaServicoDto;\n	}\n\n	private String generatePassword() throws NoSuchAlgorithmException {\n		KeyGenerator gen = KeyGenerator.getInstance(""HmacSHA256"");\n		return new String(Base64.getUrlEncoder().withoutPadding().encode(gen.generateKey().getEncoded()));\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.arquivo.model.Arquivo;\nimport br.ufsc.bridge.pecassinador.arquivo.repository.ArquivoRepository;\n\nimport jakarta.transaction.Transactional;\n\n@Service\n@RequiredArgsConstructor\npublic class ArquivoDeleteService {\n	private final ArquivoRepository arquivoRepository;\n	private final StorageDeleteService storageDeleteService;\n\n	@Transactional\n	public void delete(Arquivo arquivo) throws IOException {\n		this.storageDeleteService.delete(arquivo.getHash() + ""_"" + arquivo.getTamanho());\n		this.arquivoRepository.delete(arquivo);\n	}\n}\n"
service,"package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\n@Service\n@RequiredArgsConstructor\npublic class StorageWriteService {\n	private final StorageResolveService storageResolveService;\n\n	public void write(String filename, byte[] bytes) throws IOException {\n		Files.write(this.storageResolveService.resolve(filename), bytes);\n	}\n}\n"
service,package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\n@Service\n@RequiredArgsConstructor\npublic class StorageDeleteService {\n	private final StorageResolveService storageResolveService;\n\n	public void delete(String filename) throws IOException {\n		Files.deleteIfExists(this.storageResolveService.resolve(filename));\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.config.RuntimeConstants;\n\nimport jakarta.annotation.PostConstruct;\n\n@RequiredArgsConstructor\n@Service\npublic class StorageResolveService {\n	private final RuntimeConstants runtimeConstants;\n\n	public Path resolve(String path) {\n		return this.getPath().resolve(path).toAbsolutePath();\n	}\n\n	private Path getPath() {\n		return Paths.get(runtimeConstants.getStorageRoot());\n	}\n\n	@PostConstruct\n	private void init() throws IOException {\n		val storageRoot = this.getPath();\n		if (!storageRoot.toFile().exists()) {\n			Files.createDirectories(storageRoot);\n		}\n	}\n}\n
service,"package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.val;\n\nimport org.springframework.stereotype.Service;\n\nimport br.ufsc.bridge.pecassinador.arquivo.model.Arquivo;\nimport br.ufsc.bridge.pecassinador.arquivo.repository.ArquivoRepository;\n\nimport jakarta.transaction.Transactional;\n\n@Service\n@RequiredArgsConstructor\npublic class ArquivoCreateService {\n	private final ArquivoRepository arquivoRepository;\n	private final StorageWriteService storageWriteService;\n	private final ArquivoHashService arquivoHashService;\n\n	@Transactional\n	public Arquivo create(String filename, byte[] data) throws IOException {\n		val arquivo = new Arquivo();\n		val hash = this.arquivoHashService.hash(data);\n\n		arquivo.setTamanho((long) data.length);\n		arquivo.setNome(filename);\n		arquivo.setHash(hash);\n\n		val storageFilename = hash + ""_"" + arquivo.getTamanho();\n\n		this.storageWriteService.write(storageFilename, data);\n\n		return this.arquivoRepository.save(arquivo);\n	}\n\n}\n"
service,package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ArquivoHashService {\n	public String hash(byte[] bytes) {\n		return DigestUtils.sha256Hex(bytes); //64 caracteres\n	}\n}\n
service,package br.ufsc.bridge.pecassinador.arquivo.service;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport lombok.RequiredArgsConstructor;\n\nimport org.springframework.stereotype.Service;\n\n@Service\n@RequiredArgsConstructor\npublic class StorageReadService {\n	private final StorageResolveService storageResolveService;\n\n	public byte[] read(String filename) throws IOException {\n		return Files.readAllBytes(this.storageResolveService.resolve(filename));\n	}\n}\n
